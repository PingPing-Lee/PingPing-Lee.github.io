(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{410:function(t,a,s){"use strict";s.r(a);var e=s(14),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("在日常开发中，图片是影响用户体验的关键因素之一，同时也很常见，而且相对于文字，图片也更容易抓住用户的眼球，但是图片组件却没想象中的那么简单。")]),t._v(" "),a("p",[t._v("React Native 的 Image 组件一共支持 4 种加载图片的方法：")]),t._v(" "),a("ul",[a("li",[t._v("静态图片资源")]),t._v(" "),a("li",[t._v("网络图片")]),t._v(" "),a("li",[t._v("宿主应用图片")]),t._v(" "),a("li",[t._v("Base64 图片")])]),t._v(" "),a("h2",{attrs:{id:"静态图片资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态图片资源"}},[t._v("#")]),t._v(" 静态图片资源")]),t._v(" "),a("p",[t._v("静态图片资源（Static Image Resources）是一种使用内置图片的方法，指的是每次访问时都不会变化的图片资源，比如应用的 Logo 图片等。把图片内置到App中，每次都是从本地直接读取，省去了下载加载等步骤，能够立即展示。")]),t._v(" "),a("p",[t._v("那具体是怎么使用静态图片资源的呢？")]),t._v(" "),a("p",[t._v("首先，把图片放到 React Native 的项目代码仓库中，然后通过 require 的方式引入图片，最后把图片的引用值传给 source 属性。Image.source 属性是用来设置图片加载来源的。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" imgSource "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'...'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 图片的相对路径，必须用字面常量,而不能用变量")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Image source"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("imgSource"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("上面我们说了require 入参不能是变量，那具体为什么不能呢？请戳这里"),a("RouterLink",{attrs:{to:"/rn/source/img.html"}},[t._v("静态图片资源的加载原理")])],1),t._v(" "),a("h2",{attrs:{id:"网络图片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络图片"}},[t._v("#")]),t._v(" 网络图片")]),t._v(" "),a("p",[t._v("网络图片（Network Images）指的是使用 http/https 网络请求加载远程图片的方式")]),t._v(" "),a("p",[t._v("在使用网络图片时，记得将宽高属性作为一个必填项来处理，如果没有填写宽高属性，初始化默认宽高是 0，网络图片就展示不了")]),t._v(" "),a("div",{staticClass:"language-jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Image")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("source")]),a("span",{pre:!0,attrs:{class:"token script language-javascript"}},[a("span",{pre:!0,attrs:{class:"token script-punctuation punctuation"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("uri")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'https://...'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("style")]),a("span",{pre:!0,attrs:{class:"token script language-javascript"}},[a("span",{pre:!0,attrs:{class:"token script-punctuation punctuation"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("width")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("height")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])])]),a("p",[t._v("注意一下，Image标签的 source 的值的书写格式是 { uri: '...' }，用的是 URI来代表图片，这是因为 URI 代表的含义更广泛，它既包括 URN 这种用名称代表图片的方式，也包括用 URL 这种地址代表图片的方式。")]),t._v(" "),a("p",[t._v("但是网络图片也并不是每次都走网络请求下载图片的，只要有缓存就能直接从本地加载。这里就要涉及 React Native 的缓存和预加载机制了，请戳这里"),a("RouterLink",{attrs:{to:"/rn/source/preload.html"}},[t._v("缓存和预加载机制")])],1),t._v(" "),a("h2",{attrs:{id:"宿主应用图片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宿主应用图片"}},[t._v("#")]),t._v(" 宿主应用图片")]),t._v(" "),a("p",[t._v("宿主应用图片（Images From Hybrid App’s Resources​）指的是 React Native 使用 Android/iOS 宿主应用的图片进行加载的方式。")]),t._v(" "),a("p",[t._v("在 React Native 和 Android/iOS 混合应用中，也就是一部分是原生代码开发，一部分是 React Native 代码开发的情况下，你可能会用到这种加载方式。")]),t._v(" "),a("p",[t._v("但在实际工作中，复用的收益抵不上复用带来的安全风险、维护成本和沟通成本，所以不推荐在 React Native 中使用宿主应用图片资源，具体分析有下面几个原因：")]),t._v(" "),a("ul",[a("li",[t._v("这种加载图片的方法没有任何的安全检查，一不小心就容易引起线上报错。")]),t._v(" "),a("li",[t._v("React Native 是动态更新的，最新代码是跨多个版本运行的，而原生应用是发版更新的，最新代码只在最新版本运行，这就导致 React Native 需要确切知道 Native 图片到底内置在哪些版本中，这对图片管理要求太高了，实现起来也麻烦。")]),t._v(" "),a("li",[t._v("React Native 的开发团队，和 Android/iOS 的开发团队很可能不是一个团队，甚至可能跨部门，调试起来也比较麻烦。")])]),t._v(" "),a("h2",{attrs:{id:"base64-图片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base64-图片"}},[t._v("#")]),t._v(" Base64 图片")]),t._v(" "),a("p",[t._v("Base64 指的是一种基于 64 个可见字符表示二进制数据的方式，Base64 图片指的是使用 Base64 编码加载图片的方法，它适用于那些图片体积小的场景。"),a("br"),t._v("\nBase64 图片的示例代码如下：")]),t._v(" "),a("div",{staticClass:"language-jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Image  source"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("uri")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 'data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("image"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("png"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("base64"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// uri 后并不是图片地址，而是一大长串的以 data:image/png; base64 开头的文本")]),t._v("\n")])])]),a("p",[t._v("通常以 .jpg、.png后缀的图片都是二进制格式的，是以独立文件存在的。而 Base64 图片并不是单独图片文件，而是以文本形式存在 .js 文件中的。上线打包之后 Base64 图片是嵌套在 Bundle 文件中的，在加载 React Native 页面的同时，Base64 字符串也能很快地解析成真正的图片，并展示出来。")]),t._v(" "),a("p",[t._v("但是也由于 Base64 图片是嵌套在 Bundle 文件中的，所以 Base64 图片的优点是无需额外的网络请求展示快，缺点是它会增大 Bundle 的体积。所以 Base64 图片只适合用在体积小的图片或关键的图片上。")]),t._v(" "),a("p",[t._v("下面我们通过一张图来简单的了解一下 Base64 的转换原理：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/rn/base/base64.webp",alt:"base64"}})]),t._v(" "),a("p",[t._v("图片中 Base64 以 3 个字节作为一组，一共是 24 比特。将这 24 个比特分成 4 个单元，每个单元 6 个比特。每个单元前面加 2 个 0 作为补位，一共 8 个比特，凑整 1 个字符。转换后原来的 24 比特，就变成了 32 比特，因此即便是相同的图片，Base64 字符串的体积也要比二进制字节码的体积要大 1/3。")])])}),[],!1,null,null,null);a.default=r.exports}}]);