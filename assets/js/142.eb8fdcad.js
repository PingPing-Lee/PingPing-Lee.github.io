(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{411:function(t,a,s){"use strict";s.r(a);var e=s(14),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("React Native 官方列表组件是 FlatList，而 FlatList 的底层实现是滚动组件 ScrollView")]),t._v(" "),a("h2",{attrs:{id:"scrollview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scrollview"}},[t._v("#")]),t._v(" ScrollView")]),t._v(" "),a("p",[t._v("ScrollView 是一个支持横向或竖向的滚动组件，只要是内容超出一屏的页面都要用到该组件")]),t._v(" "),a("p",[t._v("在实际开发中使用 ScrollView 组件时，通常并不直接给 ScrollView 设置固定高度或宽度，而是给其父组件设置固定高度或宽度")]),t._v(" "),a("p",[t._v("而 ScrollView 的父组件一般是可以实现适配 iPhone 的刘海屏的安全区域组件 SafeAreaView，并给 SafeAreaView 组件设置布局属性 flex:1")]),t._v(" "),a("div",{staticClass:"language-jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SafeAreaView")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("style")]),a("span",{pre:!0,attrs:{class:"token script language-javascript"}},[a("span",{pre:!0,attrs:{class:"token script-punctuation punctuation"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("flex")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n  ")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ScrollView")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n    ...\n  ")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ScrollView")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SafeAreaView")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("    \n")])])])]),a("p",[t._v("虽说 FlatList 的滚动是通过 ScrollView 实现的，但是我们也不能直接通过 ScrollView 来渲染长列表视图，这是因为 ScrollView 没有做任何懒加载优化，组件把其内部子组件看做一个整体，只做整体的渲染，因此所有内容都会在首次刷新时进行渲染。如果内容过多，加载速度就会很慢")]),t._v(" "),a("p",[t._v("也正是因为这个原因，React Native 官方推出了自动按需渲染的列表组件 FlatList")]),t._v(" "),a("h2",{attrs:{id:"flatlist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flatlist"}},[t._v("#")]),t._v(" FlatList")]),t._v(" "),a("p",[t._v("列表组件 FlatList 把其内部子组件看做由一个个列表项组成的集合，每一个列表项都可以单独渲染或者卸载，这也正是自动按需渲染的前提")]),t._v(" "),a("p",[t._v("简单地讲，FlatList 列表组件利用按需渲染机制减少了首次渲染的视图，利用空视图的占位机制回收了原有视图的内存")]),t._v(" "),a("p",[t._v("具体点说，当页面滚动时，会触发滚动组件 ScrollView 组件的一个“异步”回调 onScroll 事件，在 onScroll 事件中，可以获取到当前滚动的偏移量 offset 等信息。再以 offset 为基础，默认向上数 10 个屏幕的高度，向下数 10 个屏幕的高度，这一共 21 个屏幕的内容就是需要按需渲染的区域，其他区域都是无需渲染的区域，用空视图代替")]),t._v(" "),a("p",[t._v("知道了按需渲染的区域，接着要计算的就是按需渲染列表项的索引。但是怎样计算，又要根据列表项的高度是否确定来决定")]),t._v(" "),a("ul",[a("li",[t._v("高度确定时，通过获取列表项布局属性 getItemLayout 告诉 FlastList 高度值，同时知道按需渲染区域，这是索引就是简单的 区域/高度值的四则运算")]),t._v(" "),a("li",[t._v("高度不确定时，FlastList 要先把列表项渲染出来才能获取高度，通过列表项的布局回调函数 onLayout 动态测量高度，通过列表项的平均高度，把索引大致估算出来")])]),t._v(" "),a("p",[t._v("有了索引后，渲染列表项就变得很简单，通过 setState 改变按需渲染区域第一个索引和最后一个索引的值，来实现按需渲染的")]),t._v(" "),a("p",[t._v("总结下来，实现 FlatList 自动按需渲染的思路具体可以分为三步：")]),t._v(" "),a("ul",[a("li",[t._v("通过滚动事件的回调参数，计算需要按需渲染的区域")]),t._v(" "),a("li",[t._v("通过需要按需渲染的区域，计算需要按需渲染的列表项索引")]),t._v(" "),a("li",[t._v("只渲染需要按需渲染列表项，不需要渲染的列表项用空视图代替")])])])}),[],!1,null,null,null);a.default=n.exports}}]);