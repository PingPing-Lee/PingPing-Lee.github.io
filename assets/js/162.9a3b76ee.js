(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{434:function(e,s,a){"use strict";a.r(s);var t=a(14),r=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("加载静态图片资源我们可以从编译、构建、运行时三个步骤去分析整个加载过程")]),e._v(" "),s("h2",{attrs:{id:"编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译"}},[e._v("#")]),e._v(" 编译")]),e._v(" "),s("p",[e._v("在引入静态图片资源完成后，如果本地运行能正常显示，可以通过运行 react-native bundle 的打包命令进行打包编译，但是在打包之前记得提前创建一个打包输出文件夹，这里以 _build 为例，指令如下：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("npx react-native bundle --entry-file index.js "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("--dev")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("--minify")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),e._v(" --bundle-output ./_build/index.bundle --assets-dest ./_build\n")])])]),s("blockquote",[s("ul",[s("li",[e._v("--entry-file index.js：以根目录的 index.js 文件为入口（entry file）")]),e._v(" "),s("li",[e._v("--dev false：产出环境，dev=false 所以是 release 包")]),e._v(" "),s("li",[e._v("--minify false：包不用压缩")]),e._v(" "),s("li",[e._v("--bundle-output ./_build/index.bundle：包命名为 index.bundle，并放在 _build 目录里")]),e._v(" "),s("li",[e._v("--assets-dest ./_build：静态资源编译产物也放到 ./build 目录里")])])]),e._v(" "),s("p",[e._v("打包完成之后，_build 文件结构如下：")]),e._v(" "),s("p",[s("img",{attrs:{src:"/img/rn/source/_build.png",alt:"_build"}})]),e._v(" "),s("p",[e._v("其中 avatar.png 是我提前存放的静态图片资源，我们可以在 index.bundle 中搜索 avatar 关键字可以发现以下模块：")]),e._v(" "),s("p",[s("img",{attrs:{src:"/img/rn/source/registerAsset.png",alt:"registerAsset"}})]),e._v(" "),s("p",[e._v("这段代码由打包工具根据字面常量'./avatar.jpg'，找到真正的静态图片资源后，读取图片信息自动生成的，其作用就是将静态图片信息，注册到一个全局管理静态图片资源中心")]),e._v(" "),s("p",[e._v("代码中 registerAsset 是 avatar 图片的注册函数，入参是图片的注册信息(//后是注册信息的具体解释)")]),e._v(" "),s("h2",{attrs:{id:"构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建"}},[e._v("#")]),e._v(" 构建")]),e._v(" "),s("p",[e._v("在应用构建时，会把上一步编译后生成的 Bundle，包括 Bundle 中的静态图片资源信息，和真正的静态图片资源都已经内置到 App 中")]),e._v(" "),s("h2",{attrs:{id:"运行时"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#运行时"}},[e._v("#")]),e._v(" 运行时")]),e._v(" "),s("p",[e._v("在运行时，require 引入的并不是静态图片资源本身，而是静态图片资源的信息。正是因为这些图片信息，找到“构建时”内置在 App 中的静态图片资源，并将图片加载和显示出来")]),e._v(" "),s("p",[e._v("如果想要查看 require 引入的到底是哪些信息，可以通过 Image.resolveAssetSource() 方法来获取，并将其打印出来如下图：")]),e._v(" "),s("p",[s("img",{attrs:{src:"/img/rn/source/resolveAssetSource.png",alt:"resolveAssetSource"}})]),e._v(" "),s("p",[e._v("resolveAssetSource 这个方法也是 Image 组件底层用来获取图片信息的方法")]),e._v(" "),s("p",[e._v("总结下来，静态图片资源的加载原理就是，在编译时通过注册函数提前获取静态图片资源的注册信息，在构建时把静态图片资源的注册信息以及资源本身都内置到 APP 应用中，在运行时，提前获取静态图片资源的信息，再通过信息找到内置在 App 中的资源本身，并将其加载显示出来。")]),e._v(" "),s("p",[e._v("这里特别提示一点就是，也正是因为在运行时，程序可以提前获取静态图片资源的信息，在图片初始化时即使不设置宽高，也是有默认宽高的，且加载速度也很快。")])])}),[],!1,null,null,null);s.default=r.exports}}]);