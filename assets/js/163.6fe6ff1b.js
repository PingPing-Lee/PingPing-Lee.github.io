(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{433:function(t,a,s){"use strict";s.r(a);var e=s(14),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("在 "),a("RouterLink",{attrs:{to:"/rn/base/img.html"}},[t._v("图片加载")]),t._v(" 中的网络图片的加载方式中，我们提到过 React Native 的缓存和预加载机制名词，下面就来简单介绍一下：")],1),t._v(" "),a("h3",{attrs:{id:"缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),a("p",[t._v("Android 和 iOS 的缓存设置方式和实现原理有所不同， Android 用的是 Fresco 第三方图片加载组件的缓存机制，iOS 用的是 NSURLCache 系统提供的缓存机制，但整体上都是采用了内存和磁盘的综合缓存机制。")]),t._v(" "),a("p",[t._v("第一次访问时，网络图片是先加载到内存中，然后再存在磁盘中的。后续如果我们需要再次访问，图片就会从缓存中直接加载，除非超出了最大缓存的大小限制。")]),t._v(" "),a("p",[t._v("如果缓存图片的体积超出了最大缓存的大小限制，一些老的缓存图片就会被删除")]),t._v(" "),a("h3",{attrs:{id:"预加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#预加载"}},[t._v("#")]),t._v(" 预加载")]),t._v(" "),a("p",[t._v("使用图片预加载机制，可以提前把网络图片缓存到本地。对于用户来说，提前缓存的图片是第一次看到的，但对于系统缓存来说图片是第二次加载，它的加载速度是毫秒级的甚至亚秒级的。这就是预加载机制，提升图片加载性能的原理")]),t._v(" "),a("p",[t._v("React Native 也提供了非常方便的图片预加载接口 Image.prefetch")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("Image"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("prefetch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("url"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// url 是图片的远程地址")]),t._v("\n")])])]),a("p",[t._v("通过图片缓存机制和预加载机制的配合，我们可以合理地利用缓存来提高图片加载速度，这能进一步地提升用户体验")])])}),[],!1,null,null,null);a.default=n.exports}}]);