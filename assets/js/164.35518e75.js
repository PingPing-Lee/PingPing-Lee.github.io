(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{436:function(t,e,a){"use strict";a.r(e);var s=a(14),p=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"什么是热更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是热更新"}},[t._v("#")]),t._v(" 什么是热更新？")]),t._v(" "),e("p",[t._v("热更新，也叫做动态更新，它是一种类似 Web 的更新方式。相对于 App 的发版更新而言，热更新能提升业务的迭代效率。")]),t._v(" "),e("p",[t._v("具体热更新和发版更新有什么不同呢？为什么能提升效率呢？我们可以通过下面这张两种更新方式的原理对比图，先了解：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/rn/update/update1.webp",alt:"update1"}})]),t._v(" "),e("p",[t._v("由图我们可以看出：")]),t._v(" "),e("ul",[e("li",[t._v("发版更新，指的是把 React Native App，当作 Android App 和 iOS App，按照其上架流程，通过各自的应用商店进行更新。从提交 -> 审核 -> 上架 -> 版本覆盖都是需要时间的，所以发版更新，就会受到发版节奏、审核耗时和版本覆盖耗时的影响，从而导致业务迭代速度变慢。")]),t._v(" "),e("li",[t._v("热更新就可以绕过应用商店直接进行更新。只要是集成热更新功能的 React Native App，在应用商店上架过一次之后，后续业务都可以走热更新流程，能随时上线，随时更新了。")])]),t._v(" "),e("p",[t._v("目前业内的主流方案有四种：Code Push、Pushy、Expo 和自研。")]),t._v(" "),e("h2",{attrs:{id:"code-push"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#code-push"}},[t._v("#")]),t._v(" Code Push")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/rn/update/codePush.html"}},[t._v("codePush")])],1)])}),[],!1,null,null,null);e.default=p.exports}}]);