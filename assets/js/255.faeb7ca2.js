(window.webpackJsonp=window.webpackJsonp||[]).push([[255],{528:function(t,a,s){"use strict";s.r(a);var n=s(14),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),a("p",[t._v("像很多其他语言一样，在编写着色器程序是，应注意以下两点：")]),t._v(" "),a("ul",[a("li",[t._v("程序是大小写敏感的，如定义变量 a 和 A 就不是同一个变量")]),t._v(" "),a("li",[t._v("每一个语句都应该以一个英文分号(;)结束")])]),t._v(" "),a("h2",{attrs:{id:"执行次序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行次序"}},[t._v("#")]),t._v(" 执行次序")]),t._v(" "),a("p",[t._v("在 WebGL 中程序不是从第一行开始执行的，而是从 main() 函数开始执行，该函数不能接收任何参数，且在着色器程序中必须有且仅有一个 "),a("strong",[t._v("main()")]),t._v(" 函数")]),t._v(" "),a("p",[a("code",[t._v("void main() {}")]),t._v(" 函数前有 void 关键字表示函数不返回任何值，如果函数有返回值也必须在定义函数是明确指定返回值的类型, "),a("code",[t._v("float main() { return f }")])]),t._v(" "),a("h2",{attrs:{id:"注释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[t._v("#")]),t._v(" 注释")]),t._v(" "),a("p",[t._v("在着色器器程序中，注释的格式和JS 中是相同的：")]),t._v(" "),a("ul",[a("li",[t._v("单行注释： // 后直到换行处的左右字符为注释")]),t._v(" "),a("li",[t._v("多行注释： /* 和 */ 之间的所有字符为注释")])]),t._v(" "),a("h2",{attrs:{id:"数据值类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据值类型"}},[t._v("#")]),t._v(" 数据值类型")]),t._v(" "),a("p",[t._v("GLSL 支持两种数据值类型：")]),t._v(" "),a("ul",[a("li",[t._v("数值类型：\n"),a("ul",[a("li",[t._v("整型数，没有小数点(.)的值，如 1，2...")]),t._v(" "),a("li",[t._v("浮点数，有小数点(.)的值，如 3.14")])])]),t._v(" "),a("li",[t._v("布尔值类型: 包括 true 和 false 两个布尔常量")])]),t._v(" "),a("p",[a("strong",[t._v("注意不支持字符串类型")])]),t._v(" "),a("h2",{attrs:{id:"变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[t._v("#")]),t._v(" 变量")]),t._v(" "),a("p",[t._v("GLSL 变量的声明和 JS 相同，都需要满足以下条件：")]),t._v(" "),a("ul",[a("li",[t._v("只能是数字字母和下划线")]),t._v(" "),a("li",[t._v("不能是数字开头")]),t._v(" "),a("li",[t._v("不能是关键字或保留字")]),t._v(" "),a("li",[t._v("不能以 gl_、 webgl_、"),a("em",[t._v("webgl")]),t._v(" 作为开头")])]),t._v(" "),a("h2",{attrs:{id:"强类型语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强类型语言"}},[t._v("#")]),t._v(" 强类型语言")]),t._v(" "),a("p",[t._v("GLSL 中如果 main() 函数有返回值，要指定返回值的类型，而且在进行赋值操作 (=) 的时候，等号左右两侧的数据类型必须要一样，所以被称为 强类型语言，在编程时要时刻注意变量的类型")]),t._v(" "),a("p",[t._v("GLSL 的基本类型：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("类型")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("float")]),t._v(" "),a("td",[t._v("单精度浮点数类型")])]),t._v(" "),a("tr",[a("td",[t._v("int")]),t._v(" "),a("td",[t._v("整型数")])]),t._v(" "),a("tr",[a("td",[t._v("bool")]),t._v(" "),a("td",[t._v("布尔值")])])])]),t._v(" "),a("p",[a("code",[t._v("int i = 8")]),t._v(" 是没有问题，但是"),a("code",[t._v("float f = 8")]),t._v("就会报错，不能直接将整型赋值给浮点型，需要将整型转换成浮点型之后再赋值 "),a("code",[t._v("int i = 8; float f = float(i);")]),t._v(" 这样就没问题")]),t._v(" "),a("p",[t._v("这里的 float() 是用于类型转换的内置函数，还有以下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/webgl/glsl/nzlxzh.png",alt:"内置类型转换函数"}})]),t._v(" "),a("h2",{attrs:{id:"基本运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本运算符"}},[t._v("#")]),t._v(" 基本运算符")]),t._v(" "),a("p",[t._v("支持的运算类型基本上和 JS 类似：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/webgl/glsl/jbysf.png",alt:"运算类型"}})]),t._v(" "),a("h2",{attrs:{id:"矢量和矩阵"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#矢量和矩阵"}},[t._v("#")]),t._v(" 矢量和矩阵")]),t._v(" "),a("p",[t._v("GLSL ES 支持多种不同的矢量和矩阵类型，如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/webgl/glsl/sljzlx.png",alt:"矢量和矩阵类型"}})]),t._v(" "),a("h3",{attrs:{id:"赋值与构造"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#赋值与构造"}},[t._v("#")]),t._v(" 赋值与构造")]),t._v(" "),a("p",[t._v("我们使用等号(=) 来对矢量和矩阵进行赋值操作，且等号左右两边的变量/值的类型必须一致，左右两边的元素个数也必须相同")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("vec4 position "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("上面的代码就会报错因为vec4类型变量有四个元素，通常使用与数据类型同名的内置构造函数来生成变量，上面的应该改成如下代码：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("vec4 position "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("vec4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这里的 vec4() 就是矢量的构造函数，还可以如下定义：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将v3 设置为 (1.0, 2.0, 3.0)")]),t._v("\nvec3 v3 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("vec3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 v3 的前两个元素，将v2 设为 (1.0, 2.0)")]),t._v("\nvec2 v2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("vec2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将 v4 设为 (1.0, 1.0, 1.0, ！.0)")]),t._v("\nvec4 v4 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("vec4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("矩阵构造函数的使用方式和矢量构造函数类似，但是存储在矩阵中的元素是按照列主序排列的")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/webgl/glsl/jzgzhs.png",alt:"矩阵构造函数"}})]),t._v(" "),a("h3",{attrs:{id:"访问元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问元素"}},[t._v("#")]),t._v(" 访问元素")]),t._v(" "),a("p",[t._v("访问矢量的元素，用点运算符(.)，访问矩阵的元素，使用[]运算符")]),t._v(" "),a("h2",{attrs:{id:"纹理取样器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#纹理取样器"}},[t._v("#")]),t._v(" 纹理取样器")]),t._v(" "),a("p",[t._v("将 GLSL ES 支持的一种内置类型称为取样器，必须通过该类型变量来访问纹理")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 声明二维纹理")]),t._v("\nuniform sampler2D uSampler"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 立方体纹理")]),t._v("\nuniform samplerCube uSamplerCube"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[t._v("有两种基本的取样器类型，sampler2D 和 samplerCube")]),t._v(" "),a("li",[t._v("取样器变量只能声明为 uniform 变量")]),t._v(" "),a("li",[t._v("唯一能赋值给取样器变量的就是纹理单元编号，而且必须使用 gl.uniform1i() 进行赋值")])]),t._v(" "),a("h2",{attrs:{id:"分支与循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支与循环"}},[t._v("#")]),t._v(" 分支与循环")]),t._v(" "),a("p",[t._v("着色器中的分支与循环和JS 中没什么不同")]),t._v(" "),a("p",[t._v("通过 if 语句 if-else 语句进行分支判断")]),t._v(" "),a("ul",[a("li",[t._v("if() {} 和 if (){} else{}")]),t._v(" "),a("li",[t._v("if () {} else if () {} else {}")])]),t._v(" "),a("p",[t._v("通过 for 语句实现循环，跳出循环可以选择 continue、break 或 discard 语句，其中 continue 和 break 的用法和 JS 一致，需要注意的是 discard 语句，只能在片元着色器中使用，表示放弃当前片元直接处理下一个片元")]),t._v(" "),a("h2",{attrs:{id:"函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),a("p",[t._v("与 JS 的函数定义不同，GLSL ES 定义函数的方式更接近于 c 语言，其格式如下")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("函数返回值类型 "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("函数名")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("参数类型 参数"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 参数类型 参数"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    函数体"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" 返回值"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nfloat "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getFloat")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("vec4 color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    函数体"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" 返回值"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"内置函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内置函数"}},[t._v("#")]),t._v(" 内置函数")]),t._v(" "),a("p",[t._v("GLSL ES 里提供了较多的内置函数，可以直接使用，如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/webgl/glsl/nzhs.png",alt:"内置函数"}})]),t._v(" "),a("h2",{attrs:{id:"存储限定字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储限定字"}},[t._v("#")]),t._v(" 存储限定字")]),t._v(" "),a("p",[t._v("在 GLSL ES 中修饰变量的限定词除了常用的 attribute、uniform 和 varying 外，还有 const 限定字，表示着色器中某个变量是常量")]),t._v(" "),a("p",[t._v("声明事需要写在类型之前，而且声明之后不能再去改变，类似声明如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" mat4 ide "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mat4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("总结下来就是：")]),t._v(" "),a("ul",[a("li",[t._v("attribute 只能出现在顶点着色器中，只能声明为全局变量，表示逐顶点信息。单个顶点的信息")]),t._v(" "),a("li",[t._v("uniform 可同时出现在 顶点着色器 和 片元着⾊器中，只读类型，强调一致性，用来存储的是影响所有顶点的数据。如变换矩阵")]),t._v(" "),a("li",[t._v("varying 从顶点着色器向片元着色器传递数据")]),t._v(" "),a("li",[t._v("const 声明一个常量，定义之后不能被改变")])]),t._v(" "),a("h2",{attrs:{id:"精度限定字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#精度限定字"}},[t._v("#")]),t._v(" 精度限定字")]),t._v(" "),a("p",[t._v("GLSL ES 引入了新的精度限定字，目的是为帮助着色器程序提高运行效率，削减内存开支")]),t._v(" "),a("p",[t._v("支持三种精度，其限定字分别为 lowp、mediump 和 highp，如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/webgl/glsl/jdxdz.png",alt:"精度限定字"}})]),t._v(" "),a("p",[t._v("示例代码如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("mediump float f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 中精度的浮点型变量")]),t._v("\nhighp vec4 position"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 高精度浮点型元素的 vec4 对象")]),t._v("\n")])])]),a("p",[t._v("上述方式为每个变量都声明精度很繁琐的，也可以使用关键字 precision 来声明着色器的默认精度，且必须在顶点着色器或者片元着色器的顶部声明")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("precision 精度限定字 类型名称"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如下")]),t._v("\nprecision mediump float"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所有浮点数默认为中精度")]),t._v("\n")])])]),a("p",[t._v("也不是每次都需要限定类型的精度，因为着色器中有默认的精度，如下图")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/webgl/glsl/mrjd.png",alt:"默认精度"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);