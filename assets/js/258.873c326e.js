(window.webpackJsonp=window.webpackJsonp||[]).push([[258],{530:function(a,t,e){"use strict";e.r(t);var r=e(14),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"构建工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构建工具"}},[a._v("#")]),a._v(" 构建工具")]),a._v(" "),t("p",[a._v("在了解 "),t("strong",[a._v("Webpack")]),a._v(" 之前，我们先来了解一下当前 Web 开发所面临的困境，如浏览器对ES6特性兼容性低，浏览器不能解析热门框架的语法糖，模块化支持不友好...等等")]),a._v(" "),t("p",[a._v("这时我们就需要有一个工具能够帮我们解决这些问题，因此衍生出 "),t("strong",[a._v("构建工具")]),a._v("，构建工具具体能做什么呢")]),a._v(" "),t("ul",[t("li",[a._v("转换 ES6 语法\n"),t("ul",[t("li",[a._v("随着ES6、ES7等广泛的使用，但是很多浏览器对ES6的很多特性支持性并不高，下图列举了 ES6 module在主流浏览器的支持情况，标红为不支持的，所以当前阶段采用构建工具转化ES6语法还是很有必要的\n"),t("img",{attrs:{src:"/img/webpack/browser.png",alt:"browser"}})])])]),a._v(" "),t("li",[a._v("转换 JSX\n"),t("ul",[t("li",[a._v("当前热门框架的一些语法糖，比如JSX，Vue的指令，Angular的指令，这些对于浏览器来说也是不能直接解析的，是需要构建工具进行转换的")])])]),a._v(" "),t("li",[a._v("CSS 前缀补全/预处理理器器\n"),t("ul",[t("li",[a._v("Lass，Sass的预处理器，使代码更易于维护，效率更高。")])])]),a._v(" "),t("li",[a._v("压缩混淆")]),a._v(" "),t("li",[a._v("图⽚片压缩")])]),a._v(" "),t("h2",{attrs:{id:"前端构建演变之路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端构建演变之路"}},[a._v("#")]),a._v(" 前端构建演变之路")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/webpack/evolution.png",alt:"evolution"}})]),a._v(" "),t("ul",[t("li",[a._v("早期前端是通过将本地代码通过线上压缩再下载到本地目录里，后面通过 ant + YUI在本地对CSS和JS进行压缩，后面由于 require.js等模块化概念不断产生，因此有了Grunt")]),a._v(" "),t("li",[a._v("Grunt 本质上是一个 Task render，会将整个构建过程分为一个个任务，每个任务去做相应的事情，比如在Grunt会将整个打包过程分为解析CSS、解析JS、解析HTML，包括图片、代码、CSS、JS的压缩，还有一些指纹等等，都会生成相应的任务，任务结束之后将任务的结果存放在本地磁盘的目录，也正是因为需要对本地磁盘进行I/O操作，所以打包比较慢，由于这个问题，就有了 Gulp")]),a._v(" "),t("li",[a._v("Gulp 做法虽然和Grunt一样，也是有任务打包器，但是有文件流的概念，每一步构建结果并不会存放在本地磁盘目录里，而且直接存放在内存中，在下一个步骤直接使用上一个步骤的内存，大大提高了打包的速度，同时期百度推出了fis3工具，对资源颗粒度比较精细，但是官方团队也不再维护，所以使用率在慢慢减少")]),a._v(" "),t("li",[a._v("目前使用相对较广的还是 Webpack")])]),a._v(" "),t("h2",{attrs:{id:"为什么选择-webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么选择-webpack"}},[a._v("#")]),a._v(" 为什么选择 webpack")]),a._v(" "),t("p",[a._v("市面上的构建工具还是很多的，最终为什什么选择 webpack，得益于Webpack社区的活跃度高\n"),t("img",{attrs:{src:"/img/webpack/Activity.png",alt:"Activity"}})]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://webpack.js.org/loaders/",target:"_blank",rel:"noopener noreferrer"}},[a._v("官方社区生态丰富"),t("OutboundLink")],1)]),a._v(" "),t("li",[a._v("配置灵活和插件化扩展\n对于不满足开发需要的情况下，可以定义自己的Loader和Plugins去满足自己业务需要")]),a._v(" "),t("li",[a._v("官⽅方更更新迭代速度快")])]),a._v(" "),t("h2",{attrs:{id:"webpack-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-是什么"}},[a._v("#")]),a._v(" webpack 是什么")]),a._v(" "),t("p",[t("strong",[t("code",[a._v("Webpack")])]),a._v(" 是一个流行的 前端项目构建工具（打包工具），可以解决当前 Web 开发中所面临的困境")]),a._v(" "),t("p",[t("strong",[t("code",[a._v("Webpack")])]),a._v(" 本质上仍然还是一个模块化打包工具，它通过“万物皆模块”这种设计思想，巧妙地实现了整个前端项目的模块化。在 Webpack 的理念中，前端项目中的任何资源都可以作为一个模块，任何模块都可以经过 Loader 机制的处理，最终再被打包到一起")]),a._v(" "),t("p",[t("strong",[t("code",[a._v("Webpack")])]),a._v(" 本身的架构中有两个很核心的特性，分别是 Loader 机制和插件机制。正是因为它的插件机制形成了非常繁荣的生态，所以造就了它现在“无所不能”的现状，所以让 程序员把工具的重心放到具体的功能实现上，提高了开发效率和项目的可维护性")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/webpack/webpack.jpg",alt:"webpack"}})])])}),[],!1,null,null,null);t.default=v.exports}}]);