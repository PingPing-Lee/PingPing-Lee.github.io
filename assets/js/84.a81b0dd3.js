(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{359:function(t,e,r){"use strict";r.r(e);var s=r(14),a=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("项目开发完成之后，定然是不能立刻上线的，在上线之前我们需要对项目进行压力测试与性能优化，只有让服务器处在高压情况下，才能真正体现出软件、硬件等各种设置不当所暴露出的问题")]),t._v(" "),e("h2",{attrs:{id:"ab"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ab"}},[t._v("#")]),t._v(" ab")]),t._v(" "),e("p",[t._v("ab 是 apache bench 命令的缩写，是 apache 自带的压力测试工具")]),t._v(" "),e("p",[t._v("ab 命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力")]),t._v(" "),e("p",[t._v("上手命令行来感受一下吧：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("ab "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("c200 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("n1600 http"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v(".0")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("download"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n")])])]),e("ul",[e("li",[t._v("－c 表示并发数，-c200 表示200个并发数")]),t._v(" "),e("li",[t._v("－n 表示请求数，-n1600 表示请求1600次")]),t._v(" "),e("li",[t._v("-t 表示压测时间，-t10 表示压测10秒")])]),t._v(" "),e("p",[t._v("运行命令之后可得到如下结果：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/node/ab.png",alt:"ab"}})]),t._v(" "),e("ul",[e("li",[t._v("Document Path: 请求的具体文件")]),t._v(" "),e("li",[t._v("Document Length: 请求的文件大小")]),t._v(" "),e("li",[t._v("Concurrency Level: 并发级别，也就是并发数，请求中 －c 参数指定的数量")]),t._v(" "),e("li",[t._v("Time taken for tests: 本次测试总共花费的时间")]),t._v(" "),e("li",[t._v("Complete requests: 本次测试总共发起的请求数量")]),t._v(" "),e("li",[t._v("Failed requests: 失败的请求数量, Failed requests / Complete requests = 请求的失败率")]),t._v(" "),e("li",[t._v("Total transferred: 总共传输的数据量")]),t._v(" "),e("li",[t._v("HTML transferred: 从服务器接收到的 html文件的总大小")]),t._v(" "),e("li",[t._v("Requests per second: QPS，服务器每秒所能承载的请求数，这是一个平均值，等于Complete requests / ime taken for tests")]),t._v(" "),e("li",[t._v("Time per request: 从用户角度看，完成一个请求所需要的时间")]),t._v(" "),e("li",[t._v("Time per request: (mean, across all concurrent requests) 服务器完成一个请求的时间")]),t._v(" "),e("li",[t._v("Transfer rate: 吞吐量，服务器每秒的网络传输速度，吞吐量越高，服务器性能越好，对于大文件的请求测试，这个值很容易成为系统瓶颈所在。要确定该值是不是瓶颈，需要了解客户端和被测服务器之间的网络情况，包括网络带宽和网卡速度等信息")])]),t._v(" "),e("p",[t._v("对于压力测试的结果是否有有分析工具呢，下面就来继续了解吧")]),t._v(" "),e("h2",{attrs:{id:"profile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#profile"}},[t._v("#")]),t._v(" profile")]),t._v(" "),e("p",[t._v("profile 是 Node.js 自带的性能分析工具，用来也比较简单，在启动命令里加上 --prof 就可以告诉 node 要获取一个性能报告，命令如下：")]),t._v(" "),e("p",[t._v("node --prof entry.js")]),t._v(" "),e("p",[t._v("命令执行完成之后，项目目录里会自动生成 isolate-0xxx-xx-v8.log 文件, 这时再对项目执行 ab 压测命令生成的日志就会被写入这个 log 文件中，这个文件内容过大，需要通过命令分析并生成 txt 文件：")]),t._v(" "),e("p",[t._v("node --prof-process isolate-0x7fda6b400000-4077-v8.log > profile.txt")]),t._v(" "),e("p",[t._v("然后可以在 txt 文件中查找  [Bottom up (heavy) profile] 项，可以看到所有的性能占比")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/node/prof.png",alt:"profile"}})]),t._v(" "),e("h2",{attrs:{id:"chrome-devtool"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#chrome-devtool"}},[t._v("#")]),t._v(" Chrome devtool")]),t._v(" "),e("p",[t._v("Node 是基于 v8 引擎的，所以除了自带的 profile，还可以用 Chrome devtool，使用起来也容易上手的，启动命令如下：")]),t._v(" "),e("p",[t._v("node --inspect-brk entry.js")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/node/inspect.png",alt:"inspect"}})]),t._v(" "),e("p",[t._v("然后在 Chrome 地址栏输入 chrome://inspect，打开以下页面：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/node/chrome.png",alt:"Chrome"}})]),t._v(" "),e("p",[t._v("点击 inspect 就可以打开谷歌调试工具，然后可以进行堆快照等方式对整体性能分析，找到最占内存的项进行优化")]),t._v(" "),e("p",[t._v("得到了性能分析结果，要如何进行优化呢？")]),t._v(" "),e("h2",{attrs:{id:"优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[t._v("#")]),t._v(" 优化")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("对与 JS 代码的性能优化的准则是 减少不必要的计算，尽量做到在启动阶段提前计算，不要把计算放到服务阶段")])]),t._v(" "),e("li",[e("p",[t._v("对于内存管理优化的准则是减少内存使用，也是提高服务性能的手段，如果有内存泄漏，会导致服务性能大大降低")])])]),t._v(" "),e("p",[t._v("这里提 一下 "),e("strong",[t._v("垃圾回收：")])]),t._v(" "),e("p",[t._v("v8 采用的内存管理机制是垃圾回收，简单的解释就是 JavaScript 引擎会记录我们创建的所有 JavaScript 对象，并且管理他们，每隔一段时间定期清理没有在被使用的对象，完成内存的释放。")]),t._v(" "),e("p",[t._v("在 v8 引擎把整个堆内存分为 新生代和老生代，所有新创建的对象都放在新生代内存里，新生代容量小，会定期执行快速垃圾回收，清理掉没在用的对象，经过几次垃圾回收都没被清理掉的对象会放到老生代里，老生代的容量更大，清理频率较低")])])}),[],!1,null,null,null);e.default=a.exports}}]);